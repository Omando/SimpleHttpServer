<style>
    p, ul {
        font-family: Calibri;
        font-size: medium;
    }

    .code {
        font-family: "Courier New";
    }

    .codeBlock {
        font-family: "Courier New";
        font-weight: bold;
    }
    pre code {
        background-color: #eee;
        border: 1px solid #999;
        display: block;
        padding: 5px;
    }

</style>

<html>
<body>
<h1>Introduction</h1>
    <p> The HTTP protocol is an internet protocol made up of TCP and IP protocols. When a browser or some other HTTP client sends an HTTP request to a machine, the data is sent in packets. These packets are assembled by the HTTP server and the server may choose to respond with some data requested by the client over the same request connection.</p>

    <p>An HTTP server is a program that listens and responds to HTTP requests coming on a specific port of the machine's address. A machine can have multiple addresses:</p>
    <ul>
        <li>An IPV4 loopback address which resolves to itself. For example, 127.0.0.1, or 192.168.1.123</li>
        <li>A static internet address, for example, 10.11.12.13</li>
    </ul>

    <p>An HTTP server may choose to listen on a  specific address or perhaps, all the machine addresses using a 0.0.0.0 address.</p>

    <p>Go provides the <span class="code">net</span> package that contains a few  utility packages to handle networking related stuff:</p>
    <ul>
        <li>
            The <span class="code">net</span> package contains the <span class="code">http</span> package which  allows browsers/http clients to make HTTP requests, and allows servers to listen and process incoming http requests. Since this package is a sub-package of the <span class="code">net</span> package, the typical Go import path will be as follows:
            <p class="code">import "net/http"</p>
        </li>
        <li>
            The <span class="code">net</span> package also has the  <span class="code">smtp</span> package to send emails using SMTP protocol.
        </li>
    </ul>
<p>See <span class="code">https://golang.org/pkg/net/#pkg-subdirectories</span> for more details<p></p>

<h1>Simple HTTP server</h1>
    <p>The <span class="code">http.ListenAndServe</span> function starts an HTTP server and <b>locks the process</b>. This means that any code below this function call will not be executed. The process will be terminated if this function returns an error or if the process is killed using a keyboard interrupt (using ctrl+c):</p>


    <p class="codeBlock">func ListenAndServe(addr string, handler Handler) error</p>

    <p>The <span class="code">http.ListenAndServe</span> function internally creates a tcp listener on address <span class="code">addr</span> using <span class="code">net.listen</span> function which returns a <span class="code">net.Listener</span> and uses it with <span class="code">http.Serve</span> function to listen to incoming connections using <span class="code">handler</span>.</p>

    <p>The <span class="code">addr</span> argument of type <span class="code">string></span> is the address of the machine on which the server will be spawned. It is the combination of IP address and port which looks like <span class="code">"<i>ip-address:port</i>"</span>. Go provides a few short cuts; you can use <span class="code">":yourportnumber"</span>, <span class="code">":http"</span> or <span class="code">":https"</span>:</p>
    <ul>
        <li>You can use <span class="code">":portnumber"</span> as well without an IP address in which case it will be reachable from all the addresses of the machine.</li>
        <li>You can also use <span class="code">":http"</span> as the <span class="code">addr</span> argument value for address port ":80"</li>
        <li>You can also use <span class="code">":https"</span> as the <span class="code">addr</span> argument value for address port ":443"</li>
    </ul>

    <p>The <span class="code">handler</span> argument of the type <span class="code">Handler</span> interface handles the incoming HTTP requests. The <span class="code">Handler</span> interface looks like below:</p>

<pre><code>type Handler interface {
    <i>ServeHTTP</i>(ResponseWriter, *Request)
}</code></pre>

    <p>We can pass a value of the type that implements this interface as an argument to the <span class="code">ListenAndServe</span> function, but typically a <span class="code">nil</span> is passed in (details below)</p>

    <h2>ServeHTTP function</h2>
    <p>Recall that the <span class="code">handle</span> argument type is <span class="code">Handler</span>, which is an interface that exposes a <span class="code">ServeHTTP</span> method. When the HTTP server is started by invoking <span class="code">ListenAndServe(addr, handler)</span> function, any incoming HTTP request will trigger the <span class="code">ServeHTTP</span> method of the <span class="code">handler</span> argument. The main job of <span class="code">ServeHTTP</span> method is to respond to the request with some data:</p>

    <p class="codeBlock">ServeHTTP(res http.ResponseWriter, req *http.Request)</p>

    <p>The <span class="code">res</span> argument contains the response object of interface type <span class="code">ResponseWriter</span>. This interface defines the <span class="code">Write</span> method which is used to write data to the HTTP response. It also has other methods to add an HTTP status code and manipulate response headers
    </p>

    <p>the <span class="code">Write</span> method signature of <span class="code">ResponseWriter</span> interface is as follows:</p>

    <p class="codeBlock">Write([]byte) (int, error)</p>

    <p>It returns the number of bytes written to the response and an error if it fails. We can simply ignore these values but the number of bytes written can be useful to send <span class="code">Content-Length</span> response header.</p>

    <p>The interesting thing to note is that the <span class="code">io.Writer</span> interface also defines a <span class="code">Write</span> method with the <u>exact signature</u>. Hence, the <span class="code">res</span> object which is an object of  type <span class="code">http.ResponseWriter</span> interface, can also be treated as an object of type <span class="code">io.Writer</span> interface (polymorphism).</p>

    <p>And because <span class="code">res</span> can be treated as an object of type <span class="code">io.Writer</span>, the following methods can be used to write data to <span class="code">res</span>:

    <p class="codeBlock">func WriteString(w io.Writer, s string) (n int, err error)</p>
    <p class="codeBlock">func Fprint(w io.Writer, a ...interface{}) (n int, err error)</p>
    <p class="codeBlock">func Fprintf(w io.Writer, format string, a ...interface{}) (n int, err error)</p>

<pre><code>func main() {
    // Create an instance of SimpleHandler. There are no field to initialize
    simpleHandler := SimpleHandler{}

    // Listen in on port 9000 on any address and use our simple handler
    // which implements the Handler interface
    http.ListenAndServe(":9000", simpleHandler)
}

// SimpleHandler implements the Handler interface
type SimpleHandler struct {}

// This method gets invoked for all incoming requests. The response gets
// sent back to the client when this method returns
func (sh SimpleHandler) ServeHTTP(res http.ResponseWriter, req *http.Request) {
    // Create response binary data
    bytes := []byte("Hello World")

    // Write the binary data to the response object using ResponseWriter.write method:
    // 	Write([]byte) (int, error) --> returns the number of bytes written to
    // the response and an error if Write() call fails.
    // We can simply ignore these values but the number of bytes written can be
    // useful to send Content-Length response header.
    res.Write(bytes)

    // Since both http.ResponseWriter and io.Writer interface implement the same
    // Write([]byte) (int, error), we can treat res as an io.Writer and use
    // any method that gets passed an io.Writer
    fmt.Fprintf(res, "Time now: %s", time.Now().Format("RFC822"))
}</code></pre>

    <h2>ServeMux struct</h2>
    <p>What we need is a route based control where different functions handle the response of different URL paths. <span class="code">ServeMux</span> can accept a function for a specific route such that an incoming request with a URL matching that route will execute the corresponding function.</p>

    <p><span class="code">ServeMux</span> is a built-in <span class="code">struct</span> type exported from the <span class="code">http</span> package that acts as HTTP request multiplexer. We can create an instance of <span class="code">ServeMux</span> and pass it as the <span class="code">handler</span> to the <span class="code">ListenAndServe()</span> call. This is possible because <span class="code">ServeMux</span> implements the <span class="code">ServeHTTP</span> method which makes it implement the <span class="code">Handler</span> interface. <b>The <span class="code">ServeHTTP</span> method implemented by the <span class="code">ServeMux</span> calls the appropriate handler function for the incoming request based on the URL route pattern</b>.</p>

    <p>For example, if <span class="code">ServeMux</span> has handler functions for <span class="code">/api/</span> and <span class="code">/api/users</span> routes, and a client makes an HTTP request with <span class="code">:9000/api/users</span> URL, the handler function registered with <span class="code">/api/users</span> will be invoked.</p>

    <p>To get a <span class="code">ServeMux</span> instance, we need to call <span class="code">http.NewServeMux</span> function. This function returns an instance of <span class="code">ServeMux</span> with the loaded capability to handle requests based on routes:</p>
    <p class="codeBlock">mux := http.NewServeMux()</p>

    <p> Internally, <span class="code">NewServeMux</span> returns the new pointer instance of <span class="code">ServeMux</span> using <span class="code">new(ServeMux)</span> function call. We can also use <span class="code">mux := &http.ServeMux{}</span> syntax to do the same thing. The reason why we need a pointer because its method has pointer receiver and we are passing it as interface of <span class="code">Handler</span> type.</p>

    <p> <span class="code">ServerMux</span> is used by registering all required routes and their corresponding handlers using  <span class="code">ServerMux.HandleFunc</span> method, which has the following signature
    <p class="codeBlock">HandleFunc(route string, handler func(ResponseWriter, *Request))
    </p>
    <p>and then passing the  <span class="code">ServerMux</span> instance to  <span class="code">ListenAndServer</span>:</p>
    <p class="codeBlock">ListenAndServe(addr, mux)</p>

<p>The following code illustrates:</p>

    <pre><code>func main() {
    // Create an instance of ServeMux
    mux := http.NewServeMux()

    // Register a few routes
    mux.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) {
        fmt.Fprintf(writer, "This is the root page")
    })

    mux.HandleFunc("/help", func(writer http.ResponseWriter, request *http.Request) {
        fmt.Fprintf(writer,"This is the help page. Time now: %s", time.Now().Format(time.RFC822))
    })

    // Listen in on port 9000 on any address and use our simple handler
    // which implements the Handler interface
    http.ListenAndServe(":9000", mux)
}</code></pre>

    <h2>DefaultServeMux</h2>
    <p>We can pass <span class="code">nil</span> as the value of <span class="code">handler</span> to the <span class="code">ListenAndServe</span> function. When we pass <span class="code">nil</span>, Go will internally use the <span class="code">http.DefaultServeMux</span> which is a global <span class="code">ServeMux</span> instance.</p>

    <p>We can add routes and handler functions to this instance using similar methods, but using the functions exposed by the <span class="code">http</span> package: <span class="code">http.HandleFunc</span> function does the exact same thing that the <span class="code">mux.HandleFunc</span> does; it adds a handler function to the <span class="code">http.DefaultServeMux</span> to handle HTTP requests of a specific route path.</p>

    <p>This modified code will behave exactly the same as the previous one. This time, we avoided the step of creating a custom <span class="code">ServeMux</span> to handle the incoming HTTP requests and used the default one provided by the <span class="code">http</span> package.</p>

    <pre><code>func main() {
    // Register a few routes
    http.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) {
        fmt.Fprintf(writer, "This is the root page")
    })
    http.HandleFunc("/help", func(writer http.ResponseWriter, request *http.Request) {
        fmt.Fprintf(writer,"This is the help page. Time now: %s", time.Now().Format(time.RFC822))
    })

    // Listen in on port 9000 on any address and use our simple handler
    // which implements the Handler interface
    http.ListenAndServe(":9000", nil)
}</code></pre>

<h2>Better responses</h2>
    <p>A normal HTTP response contains headers to inform the browser about the response. The <span class="code">ResponseWriter</span> interface offers the following useful methods:</p>
<ul>
<li>The <span class="code">ResponseWriter.Header()</span> returns the object of <span class="code">Header</span> type. This object contains the map of header keys and values. We can use <span class="code">Add</span>, <span class="code">Set</span> and <span class="code">Del</span> methods to manipulate the response headers. We can use the <span class="code">Get</span> method to read existing response headers.</li>
        <li>The <span class="code">ResponseWriter.WriteHeader(int)</span> method writes the HTTP status code header to the response. However, this method is called implicitly by Go when first <span class="code">ResponseWriter.Write()</span> call is made with status code 200 (<span class="code">http.StatusOK</span> constant value). We should pass valid HTTP status integer code or use constants provided by the <span class="code">http</span> package.</li>
</ul>
    <p>The following code adds a <span class="code">Content-Type</span> header and resets the <span class="code">Date</span> header from the response. The code also sends a JSON string as a response. To notify the browser that the incoming response is of the JSON type, the code sets <span class="code">application/json</span> as the value of <span class="code">Content-Type</span> header:</p>

    <pre><code>func main() {
    // Register a few routes
    http.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) {

        // Get the response header
        header := writer.Header()

        // Let browser know we are sending back JSON
        header.Set("Content-Type", "application/json")

        // Reset header data
        header.Set("Date", time.Now().Format(time.RFC3339))

        // Reset header status
        writer.WriteHeader(http.StatusOK)

        // Respond with a JSON string
        fmt.Fprint(writer, `{"status":"OK"}`)
    })

   http.HandleFunc("/help", func(writer http.ResponseWriter, request *http.Request) {
        fmt.Fprintf(writer,"This is the help page. Time now: %s", time.Now().Format(time.RFC822))
    })

    // Listen in on port 9000 on any address and use our simple handler
    // which implements the Handler interface
    http.ListenAndServe(":9000", nil)
}</code></pre>

    <h1>Serving files</h1>
    <p>The <span class="code">http.FileServer()</span> function provides the functionality to serve the entire file-system directory with indexes:</p>
    <p class="codeBlock">func FileServer(root FileSystem) Handler</p>
    <p>The <span class="code">root</span> argument of type <span class="code">FileSystem</span> represents the file-system directory from which the content will be served. We can create a <span class="code">FileSystem</span> instance as follows:</p>
    <p class="codeBlock">var fs FileSystem = http.Dir("/tmp")</p>

    <p>An index is a list of files and folders contained in a directory. When a directory does not contain <span class="code">index.html</span> file, these servers take the responsibility of returning HTML with a list of these files and folders. This is the output of the code below</p>

    <pre><code>var fileSystem = http.Dir("C:\\Projects_Go\\SimpleHttpServer")
var fileServer = http.FileServer(fileSystem);
http.Handle("/files<b>/</b>", http.<b>StripPrefix</b>( "/files", fileServer ))    // requires a trailing /</code></pre>

<p>Note two issues with the code:
    <ul>
        <li><span class="code">http.Handle</span> in comparison with <span class="code">http.HandleFunc</span> needs a trailing / to successfully work. </li>
        <li>The <span class="code">http.FileServer</span> serves the file by looking at the request URL. Since our request URL is <span class="code">c:/projects/projects_go/simplehttpserver/files</span>, it will try to look for files inside root directory with the path <span class="code">/files</span> and it does not exist. We remove <span class="code">/files</span> part from the URL using <span class="code">http.StripPrefix</span></li>
    </ul>
</p>

    <h2>ServeFile function</h2>
    <p>The <span class="code">http</span> package provides a <span class="code">ServeFile</span> function to serve a file on the disk using its file path. This function has the below syntax:</p>
        <p class="codeBlock">func ServeFile(w http.ResponseWriter, r *http.Request, name string)</p>

    <h1>Secure HTTPS servers</h1>
    <p>The simplest HTTP server requires only <span class="code">http.ListenAndServe</span> function to start an HTTP server, and <span class="code">http.HandleFunc</span> to register a response handler for a particular endpoint.</p>

    <p>To start an HTTPS server, all we need do is to call <span class="code">ListenAndServeTLS</span> method with some configuration:</p>
    <p class="codeBlock">func ListenAndServeTLS(addr string, <i>certFile string, keyFile string</i>, handler Handler) error</p>

    <p>Note the additional <span class="code">certFile</span> and <span class="code">keyFile</span> arguments. These are the paths to the SSL certificate file and private key file, respectively.</p>

    <h3>Generating a private key and an SSL certificate</h3>
    <p>The following command generates a <span class="code">localhost.key</span> file which is the private key, and <span class="code">localhost.csr</span> which is the certificate signing request that contains the public key.</p>
    <p class="codeBlock">$ openssl req -new -newkey rsa:2048 -nodes -keyout <span style="color: red">localhost.key</span> -out localhost.csr</p>
    <p>This command generates the <span class="code">localhost.crt</span> file which is the self-signed certificate signed by our own <span class="code">localhost.key</span> private key. The <span class="code">x509</span> flag states the standard format of an SSL/TLS certificate which is X.509.</p>
    <p class="codeBlock">$ openssl  x509  -req  -days 365  -in localhost.csr  -signkey localhost.key  -out <span style="color: red">localhost.crt</span></p>

    <p>Now that we have both private key and certificate files, we can modify our earlier Go program and use <span class="code">ListenAndServeTLS</span> method instead:</p>
    <pre><code>http.ListenAndServeTLS(":9000", "localhost.crt", "localhost.key", nil)</code></pre>

    <h3>ListAndServerTLS method</h3>
    <p><span class="code">http.Server</span> struct is used to define parameters for running an HTTP server. The following is a minimum configuration for an HTTPS server:</p>

    <pre><code>type Server struct {
    Addr    string          // TCP address to listen on
    Handler Handler         // http.DefaultServeMux if `nil`
    TLSConfig *tls.Config   // TLS configuration for HTTPS protocolz

}</code></pre>

    <p>An <span class="code">http.Server</span> instance has similar methods exported by <span class="code">http</span> package like <span class="code">ListenAndServe</span>, <span class="code">ListenAndServeTLS</span>, etc. The following shows how to initialize an instance of <span class="code">http.Server</span> to start an HTTP server:</p>

    <pre><code>// Register a few routes
http.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) {
    // Get the response header
    header := writer.Header()

    // Let browser know we are sending back JSON
    header.Set("Content-Type", "application/json")

    // Reset header data
    header.Set("Date", time.Now().Format(time.RFC3339))

    // Reset header status
    writer.WriteHeader(http.StatusOK)

    // Respond with a JSON string
    fmt.Fprint(writer, `{"status":"OK"}`)
})
http.HandleFunc("/help", func(writer http.ResponseWriter, request *http.Request) {
    fmt.Fprintf(writer,"This is the help page. Time now: %s", time.Now().Format(time.RFC822))
})

// Handler to server a file system directory
var fileSystem = http.Dir("C:\\Projects_Go\\SimpleHttpServer")
var fileServer = http.FileServer(fileSystem);
http.Handle("/files/", http.StripPrefix( "/files", fileServer ))		// requires a trailing /

// Create a custom server
var server http.Server = http.Server{
    Addr: ":9000",
    Handler: nil,		// uses http.DefaultServerMux
}
log.Fatal(server.ListenAndServeTLS("localhost.crt", "localhost.key"))</code></pre>

    <p>Compare the code above with the previous code that used <span class="code">http.ListenAndServer</span></p>
    <pre><code>// Same as above
        ...
// Listen in on port 9000 on any address and use our simple handler
// which implements the Handler interface
http.ListenAndServe(":9000", nil)</code></pre>

<h2>TLSConfig field</h2>
    <p>The <span class="code">TLSConfig</span> field of the Server structure has the <span class="code">*tls.Config</span> type. The <span class="code">Config</span> structure provided by the <span class="code">crypto/tls</span> package configures the TLS parameters of <span class="code">http.Server</span> like server certificates among others. All fields of the <span class="code">Config</span> structure are optional. Hence assigning an empty struct value to <span class="code">TLSConfig</span> field won’t be any different than assigning a <span class="code">nil</span> value just like before.</p>

    <p>The <span class="code">Certificates</span> field of the <span class="code">Config</span> structure sets a list of private key and SSL certificate pairs to use when a client connects to the server. Depending on the client's TLS handshake, a suitable pair is chosen automatically by Go. The <span class="code">Certificate</span> is a complex structure type on its own. To generate one, use <span class="code">tls.LoadX509KeyPair</span> function:</p>
    <p class="codeBlock">func LoadX509KeyPair(certFile, keyFile string) (Certificate, error)</p>

    <p>The following code illustrates</p>
    <pre><code>// Generate a certificate struct
certificate, err := tls.LoadX509KeyPair("localhost.crt", "localhost.key")
if err != nil {
    log.Fatalf("Error loading certificate: %s", err.Error())
}

// Create a custom server
var server http.Server = http.Server{
    Addr: ":9000",
    Handler: nil,		// uses http.DefaultServerMux
    TLSConfig: &tls.Config{
            Certificates: []tls.Certificate{certificate},
        },
    }
log.Fatal(server.ListenAndServeTLS("",""))</code></pre>

    <p>https://medium.com/rungo/secure-https-servers-in-go-a783008b36da<br>https://medium.com/jspoint/a-brief-overview-of-the-tcp-ip-model-ssl-tls-https-protocols-and-ssl-certificates-d5a6269fe29e</p>

    <h1>Running multiple HTTP servers</h1>
<p>Recall that <span class="code">http.ListenAndServer</span> is a blocking function. When we call <span class="code">http.ListenAndServer()</span> with appropriate arguments, it starts an HTTP server and <i>blocks the current goroutine</i>. If we run this function inside the <span class="code">main</span> function, it will block the <span class="code">main</span> goroutine (started by the <span class="code">main</span> function). So what if we want to run multiple servers? The following is the standard pattern to spawn multiple HTTP servers:</p>

<pre><code>func main() {
    <b>// Create a wait group (count down) to wait for two http servers to terminate
    waitGroup := sync.WaitGroup{}
    waitGroup.Add(2)</b>

    // Register a few routes (shared by both server, for now)
    http.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) {
        // Get the response header
        header := writer.Header()

        // Let browser know we are sending back JSON
        header.Set("Content-Type", "application/json")

        // Reset header data
        header.Set("Date", time.Now().Format(time.RFC3339))

        // Reset header status
        writer.WriteHeader(http.StatusOK)

        // Respond with a JSON string
        fmt.Fprint(writer, `{"status":"OK"}`)
    })
    http.HandleFunc("/help", func(writer http.ResponseWriter, request *http.Request) {
        fmt.Fprintf(writer,"This is the help page. Time now: %s", time.Now().Format(time.RFC822))
    })

    // Handler to server a file system directory
    var fileSystem = http.Dir("C:\\Projects_Go\\SimpleHttpServer")
    var fileServer = http.FileServer(fileSystem);
    http.Handle("/files/", http.StripPrefix( "/files", fileServer ))		// requires a trailing /

    <b>// Start one server
    go func() {
        // Listen in on port 9000 on any address
        log.Fatal(http.ListenAndServe(":9000", nil))
        waitGroup.Done()
    }()

    // Start another server
    go func() {
        // Listen in on port 9000 on any address
        log.Fatal(http.ListenAndServe(":9001", nil))
        waitGroup.Done()
    }()

    // Wait for both servers to terminate
    waitGroup.Wait()</b>
}</code></pre>

<p>The code above uses Go's standard implementation of an HTTP server. This means both of our HTTP servers are using the same handlers. For example <span class="code">http://127.0.0.1:9000/files/</span> and <span class="code">http://127.0.0.1:9001/files/</span> will both invoke the same <span class="code">/files</span> handler. The solution is to provide separate routing mechanisms.</p>

<h2>http.Server type</h2>
<p>To provide each http server with its own routing handles, we could create a distinct <span class="code">ServeMux</span> for each of these servers. Recall how <span class="code">ServeMux</span> is used:</p>

<pre><code>func main() {
    // Create an instance of ServeMux
    mux := http.NewServeMux()

    // Register a few routes
    mux.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) {
        fmt.Fprintf(writer, "This is the root page")
    })

    mux.HandleFunc("/help", func(writer http.ResponseWriter, request *http.Request) {
        fmt.Fprintf(writer,"This is the help page. Time now: %s", time.Now().Format(time.RFC822))
    })

    // Listen in on port 9000 on any address and a ServerMux instance
    // (htpp.ServerMux implements the Handler interface)
    http.ListenAndServe(":9000", mux)
}</code></pre>

<p>While the above approach works, a more elegant solution is to create and configure a custom HTTP server using the <span class="code">http.Server</span> struct:</p>
<ul>
    <li>The <span class="code">Addr</span> and <span class="code">Handler</span> fields are similar to <span class="code">http.ListAndServer</span> parameters.</li>
    <li>The <span class="code">ReadTimeout</span> and <span class="code">WriteTimeout</span> fields are important for added safety.</li>
    <li><span class="code">ErrorLog</span> is <b>crucial</b> to log any errors thrown by the server while processing a request.</li>
</ul>

<p>The following code illustrates:</p>
<pre><code>func createServer(port int) *http.Server {
    // Create a new ServeMux: Recall that a ServeMux is an HTTP request multiplexer.
    // It matches the URL of each incoming request against a list of registered patterns
    //and calls the handler for the pattern that most closely matches the URL.
    mux := http.NewServeMux()

    // Register a handle for the root
    mux.HandleFunc("/", func(writer http.ResponseWriter, request *http.Request) {
        // Get the response header
        header := writer.Header()

        // Let browser know we are sending back JSON
        header.Set("Content-Type", "application/json")

        // Reset header data
        header.Set("Date", time.Now().Format(time.RFC3339))

        // Reset header status
        writer.WriteHeader(http.StatusOK)

        // Respond with a JSON string
        fmt.Fprint(writer, `{"status":"OK"}`)
    })

    mux.HandleFunc("/help", func(writer http.ResponseWriter, request *http.Request) {
        fmt.Fprintf(writer, "This is the help page. Time now: %s", time.Now().Format(time.RFC822))
    })

    // Create a new http server by initializing a Server struct with appropriate parameters
    // for running an HTTP server.
    server := http.Server{
        Addr: fmt.Sprintf(":%v", port),
        Handler: mux,
    }

    return &server
}

func main() {
    // Create a wait group (count down) to wait for two http servers to terminate
    waitGroup := sync.WaitGroup{}
    waitGroup.Add(2)

    // Start one server
    go func() {
        <b>server := createServer(9000)</b>

        // No arguments are required for ListenAndServe since the configuration of the
        // server is present in the server struct itself.
        err := server.ListenAndServe()
        if err != nil {
            log.Printf("Server at port 9000 failed: %s\n", err.Error())
        }
        waitGroup.Done()
    }()

    // Start another server
    go func() {
        <b>server := createServer(9001)</b>

        // No arguments are required for ListenAndServe since the configuration of the
        // server is present in the server struct itself.
        err := server.ListenAndServe()
        if err != nil {
            log.Printf("Server at port 9001 failed: %s\n", err.Error())
        }
        waitGroup.Done()
    }()

    // Wait for both servers to terminate
    waitGroup.Wait()
}</code></pre>

<p>Here are some common methods on <span class="code">http.Server</span> struct:</p>
<p><span class="code">Server.SetKeepAliveEnabled</span>: Enables the HTTP persistent connection. By default, this is enabled for better performance</p>
<p><span class="code">Server.Close</span>: Once a server is no longer needed, we can close it without terminating the main program by calling this method. The following code shows an example:</p>

<pre><code>func main() {
    // create channels for safe exit
    exitSignal := make( chan interface{} )

    // create server to run on port the 9000
    server := &http.Server {
        Addr: ":9000",
        Handler: nil, // use `DefaultServeMux`
    }

    // close server after 3 seconds.
    time.AfterFunc( 3 * time.Second, func() {
        fmt.Println("Close(): completed!")
        server.Close()
        // closing exitSignal unblocks the main goroutine
        close( exitSignal ) // close `exitSignal` channel
    })

    // launch server
    err := server.ListenAndServe()
    fmt.Println( "ListenAndServe():", err )

    // listen to `exitSignal` channel
    <- exitSignal
    fmt.Println("Main(): exit complete!")
}</code></pre>
<p><span class="code">Server.Shutdown</span>: This method behaves exactly like <span class="code">server.Close</span> but allows you to register a function to perform any required clean up operations.</p>

<p>https://medium.com/rungo/running-multiple-http-servers-in-go-d15300f4e59f</p>

<h1>Making external HTTP requests</h1>
<p>When a browser sends an HTTP request to a server, it sends an HTTP request object that contains the starting line,
    an optional set of headers and an optional body containing data associated with the request.
    When the server receives the request, it responds with an HTTP response object with a similar structure to that of
    the HTTP request. A backend (server) can also act as a browser, and it too can send HTTP requests to fetch some data from
    a remote server. However, the mechanism to send a request and handle the response is manual.</p>

<h3>http.Get</h3>
<p>The <span class="code">http.Get</span> function sends an HTTP GET request to a remote server.</p>
<p class="codeBlock">func Get(url string) (res *Response, err error)</p>
<p>The <span class="code">url</span> is a fully qualified URL string. If the server responds with a redirect,
    <span class="code">http.Get</span> follows the redirect URL up to a maximum of 10 redirects. </p>
<xx></xx>
<p>If we look at the field of <span class="code">http.Response</span> object, the most important fields are:</p>
<ul>
    <li><span class="code"><b>StatusCode</b></span> (<span class="code">int</span>): indicates the HTTP response
        status code</li>
    <li><span class="code"><b>Header</b></span> (<span class="code">http.Header</span>):A <span class="code">map</span>-derived
        type which contains the response headers</li>
    <li><span class="code"><b>Body</b></span> (<span class="code">io.ReadCloser</span> interface): contains the raw
        response body</li>
</ul>
    <p>The following shows a basic usage of http.Get to fetch some JSON from a mock data website:</p>

<pre><code>mux.HandleFunc("/get", func(writer http.ResponseWriter, request *http.Request) {
    // Request some data from a remove server
    res, err := http.Get("https://jsonplaceholder.typicode.com/todos/1")

    // Check for errors
    if err != nil {
        fmt.Fprintf(writer, "Error: %v", err)
    } else {
        // Read the response body
        data, _  := <b>ioutil.ReadAll(res.Body)</b>

        // Get the value of the Content-Type header
        contentType := res.Header.Get("Content-Type")

        // Close the response body and send data back. The data variable contains the response
        // body as []byte slice. Since JSON data is a text data, we can print it as a string.
        res.Body.Close()
        fmt.Fprintf(writer, "%s\n", data)
        fmt.Fprintf(writer, "%s\n", contentType)
    }
})</code></pre>

<h3>http.Post</h3>
<p>The <span class="code">http.Post</span> function sends an HTTP POST request to a remote server with an
    optional request body:</p>

<p class="codeBlock">func Post(url, contentType string, body io.Reader) (*Response, error)</p>

<p>The <span class="code">contentType</span> argument sets the value of the <span class="code">Content-Type</span>
    header in the POST request that gets sent to the server. This header describes the type of data we are sending in
    the <span class="code">body</span> argument. The following example shows how to use <span class="code">http.Post</span>.
    Note the use of <span class="code">strings.NewReader</span> to create the body for the <span class="code">
        POST</span> request:</p>

<pre><code>mux.HandleFunc("/post", func(writer http.ResponseWriter, request *http.Request) {
    // Request body: Since request body should be io.Reader object, strings.NewReader function
    // is used to create an io.Reader from a JSON string
    var body *strings.Reader = strings.NewReader(`{"title":"My title", "body": "Some body", "userId": 1 }`)

    // Sent a post request
    var contentType string = "application/json;charset=UTF-8"
    res, err := http.Post("https://jsonplaceholder.typicode.com/posts", contentType, body )

    if err != nil {
        fmt.Fprintf(writer, "Error: %v", err)
    } else {
        // Read response data
        data, _ := ioutil.ReadAll(res.Body)
        res.Body.Close()

        // Display response data
        fmt.Fprintf(writer ,"%s\n", data)
    }
})</code></pre>

<p>If you have a JSON compatible data structure like <span class="code">struct</span> or <span class="code">map</span>,
    then you can use <span class="code">json.Marshal</span> function to encode the data structure to JSON data,
    and then use <span class="code">bytes.NewReader</span> function to convert JSON data to an <span class="code">
        io.Reader object</span>.</p>


<h3>Custom requests</h3>
<p>Previous sections showed how to use <span class="code">http.Get</span> and <span class="code">http.Post</span> to
    send simple HTTP requests. These functions take care of setting up all required HTTP headers. The following shows
    how to set up custom request headers.</p>

<p>The <span class="code">http.Request</span> struct configures the request to be sent. <span class="code">http.Get</span>,
    <span class="code">Post</span> and other methods actually construct an <span class="code">http.Request</span> object
    internally. This structure has multiple fields to configure TLS connection, keep-alive connection, form data, and
    other settings, but the following fields are minimal configuration:</p>
<pre><code>type Request struct {S
    // HTTP method (GET, POST, PUT, etc.)
    Method string

    // request URL valu
    URL *url.URL

    // request header fields
    Header Header

    // request body
    Body io.ReadCloser
}</code></pre>

<p>The <span class="code">*http.Request</span> struct implements many methods to modify the request object before
    it is sent. The <span class="code">*Request.AddCookie</span> method adds a cookie on the request object
    and <span class="code">*Request.SetBasicAuth</span> sets the basic authorization header on the request</p>

<p>Once we construct a request object, we need to make a request with this request object manually. This is done
    using <span class="code">*Client.Do</span> method. The following example illustrates:</p>

<pre><code>mux.HandleFunc("/post-man", func(writer http.ResponseWriter, request *http.Request) {
    requestUrl, _ := url.Parse("https://jsonplaceholder.typicode.com/posts")

    var bodyReader *strings.Reader = strings.NewReader(`{"title":"My title", "body": "Some body", "userId": 1 }`)
    var body io.ReadCloser = ioutil.NopCloser(bodyReader)

    // Create an http request
    serverRequest := &http.Request{
        URL: requestUrl,
        Method: "POST",
        Body: body,
        Header: http.Header{
            "Content-Type" : {"application/json;charset=UTF-8"},
        },
    }

    // Send the http request using DefaultClient.Do method which returns the network
    // response and a non-nil error if the request fails
    res, err := http.DefaultClient.Do(serverRequest)
    if err != nil {
        fmt.Fprintf(writer, "Error: %v", err)
    } else {
        // Read response data
        data, _ := ioutil.ReadAll(res.Body)
        res.Body.Close()

        // Display response data
        fmt.Fprintf(writer ,"%s\n", data)
    }
})</code></pre>

<p>The request body stored in <span class="code">Request.Body</span> field should be an object that implements
    <span class="code">io.ReadCloser</span> interface (a group of <span class="code">io.Reader</span> and
    <span class="code">io.Closer</span> interfaces). The <span class="code">strings.NewReader</span> returns an
    <span class="code">io.Reader</span> object and <span class="code">ioutil.NopCloser</span> function adds
    <span class="code">Close()</span> method on the <span class="code">io.Reader</span> object. The <span class="code">Close
    </span> method added by the <span class="code">NopCloser</span> function does nothing, it simply returns a
    <span class="code">nil</span> error. The request body is closed for I/O via this <span class="code">Close()</span>
    method call when the request is sent.</p>

<p>Note that we can simplify the code a bit by using the <span class="code">http.NewRequest</span> function to
    construct <span class="code">*http.Request</span> object from some simple values which has the following syntax:</p>

<p class="codeBlock">func NewRequest(method, url string, body io.Reader) (*Request, error)</p>

<p>This function returns a <span class="code">*http.Request</span> object and a non-nil error in case some argument
    values are not valid. If method argument is empty, a <span class="code">GET</span> request is assumed.
    We can then add headers to the returned <span class="code">*Request</span> object.</p>

<h3>http.Client structure</h3>
<p>The previous sections used <span class="code">http.Get</span> and <span class="code">http.Post</span> to send HTTP
    requests. The actual implementation of <span class="code">http.Get</span> in the <span class="code">http</span> package
    looks like this:</p>

<pre><code>// DefaultClient is the default Client and is used by Get, Head, and Post.
var DefaultClient = &Client{}

func Get(url string) (resp *Response, err error) {
	return DefaultClient.Get(url)
}</code></pre>

<p>To send HTTP requests, we have to use an <span class="code">http.Client</span> struct object. For simple HTTP requests,
    we do not have to create our own instance of <span class="code">http.Client</span>, since the <span class="code">http</span>
    package provides a global <span class="code">http.Client</span> struct instance through the
    <span class="code">http.DefaultClient</span> variable. <span class="code">http.DefaultClient</span> therefore represents
    a minimal configuration of the <span class="code">http.Client</span> structure enough to send simple HTTP requests.</p>

<p><span class="code">http.Client</span> struct looks like this:</p>
<pre><code>type Client struct {
  // mechanism by which individual HTTP requests are made
  Transport RoundTripper

  // specifies the policy for handling redirects
  CheckRedirect func(req *Request, via []*Request) error

  // specifies the cookie jar
  Jar CookieJar

  // specifies a time limit for requests
  Timeout time.Duration
}</code></pre>

<p>The <span class="code">Transport</span> field is an object that implements the <span class="code">RoundTrip</span> interface.
    This object is responsible for executing a single HTTP request and returning a response. If this field value is
    <span class="code">nil</span>, <span class="code">http.DefaultTransport</span> of type <span class="code">*http.Transport</span>
    is used. In most cases, this default value is good enough for us.</p>

<p>The <span class="code">CheckRedirect</span> field is a function that checks if a redirection demanded by a response
    must be followed. If this value is <span class="code">nil</span>, the default policy of maximum 10 redirects is
    used. The <span class="code">req</span> argument is the newest request and the <span class="code">via</span> argument
    contains the older requests (in old first order). If this function returns a non-nil error, the redirection attempt
    is blocked.</p>

<p>The <span class="code">Jar</span> field specifies a mechanism to add cookies on outgoing HTTP requests and cache
    cookies from the incoming responses. This cookie jar is consulted for every outgoing and redirected request.
    If this value is <span class="code">nil</span>, cookies are only sent if they are specified on the request (and
    copied to redirected requests). In the case of a redirected request, cookie jar can mutate the values of the cookie.
    You can use the <span class="code">net/http/cookiejar</span> package to create your customized cookie jar.</p>

<p>The <span class="code">Timeout</span> Timeout specifies a time limit for requests made by this <span class="code">Client</span>.
    The timeout includes connection time, any redirects, and reading the response body. The timer remains running after
    <span class="code">Get</span>, <span class="code">Head</span>, <span class="code">Post</span>, or <span class="code">Do</span> return
    and will interrupt reading of the <span class="code">Response.Body</span>. A Timeout of zero means no timeout.</p>

<p>The following code illustrates:</p>

<pre><code>// create a new HTTP client
client := &http.Client {
    Timeout: 100 * time.Microsecond,
}

// send an GET request from `client`
res, err := client.Get( "https://jsonplaceholder.typicode.com/users/1" )

// check for response error
if err != nil {

    // get `url.Error` struct pointer from `err` interface
    urlErr := err.( *url.Error )

    // check if error occurred due to timeout
    if urlErr.Timeout() {
        fmt.Println( "Error occurred due to a timeout." );
    }

    // log error and exit
    log.Fatal( "Error:", err )
} else {
    fmt.Println( "Success: status-code", res.StatusCode );
}</code></pre>

<p>https://medium.com/rungo/making-external-http-requests-in-go-eb4c015f8839</p>
<p>https://jsonplaceholder.typicode.com/guide/</p>
</body>
</html>